### 1. 사용자가 웹브라우저 검색창에 www.google.com 입력

### 2. 웹브라우저는 캐싱된 DNS 기록들을 통해 해당 도메인주소와 대응하는 IP주소를 확인

이 단계에서 캐싱된 기록에 없을 경우, 다음단계로 넘어간다.

### 3. 웹브라우저가 HTTP를 사용하여 DNS에게 입력된 도메인 주소를 요청

### 4. DNS가 웹브라우저에게 찾는 사이트의 IP주소를 응답

ISP(Internet Service Provider)의 DNS서버가 호스팅하고 있는 서버의 IP주소를 찾기 위해 DNS query를 날린다.

- **DNS query의 목적**
  DNS 서버들을 검색해서 해당 사이트의 IP주소를 찾는데에 있다.
  IP주소를 찾을 때 까지 DNS서버에서 다른 DNS서버를 오가며 에러가 날때까지 반복적으로 검색한다. = `recursive search`

`DNS recursor`(ISP의 DNS서버)는 `name server`들에게 물어물어 올바른 IP주소를 찾는데에 책임이 있다. `name server`는 도메인 이름 구조에 기반해서 주소를 검색하게 되는데, 예를 들어 설명해보자면,
![img](https://velog.velcdn.com/images%2Feassy%2Fpost%2F6532ce5b-3256-4f9e-a1a3-1d2c09e7b2bd%2Fimage.png)

```null
'www.google.com' 주소에 대해 검색할 때,
1. DNS recursor가 root name server에 연락
2. .com 도메인 name server로 리다이렉트
3. google.com name server로 리다이렉트
4. 최종적으로 DNS기록에서 'www.google.com' 에 매칭되는 IP주소 찾기
5. 찾은 주소를 DNS recursor로 보내기
```

이 모든 요청들과 `DNS recursor`, IP주소는 작은 데이터 패킷을 통해 보내진다.
원하는 DNS기록을 가진 DNS서버에 도달할 때까지
클라이언트 ↔️ 서버를 여러번 오가는 과정을 거친다.

### 5. 웹브라우저가 웹서버에게 IP주소를 이용하여 html문서를 요청

TCP로 연결이 되면, 브라우저는 GET요청을 통해 서버에게 www.google.com의 웹페이지를 요구한다.

### 6. 웹어플리케이션서버(WAS)와 데이터베이스에서 우선 웹페이지 작업을 처리

웹 서버 혼자서 모든 로직을 수행하고 데이터를 관리할 수 있다면 간단하겠지만,
그렇게 될 경우엔 서버에 과부하가 일어날 수 있다.
그렇기 때문에 서버의 일을 돕는 조력자 역할을 하는 것이 `웹어플리케이션서버(Web Application Server)`이다.
WAS는 **사용자의 컴퓨터나 장치에 웹어플리케이션을 수행해주는 미들웨어**를 말한다.

브라우저로부터 요청을 받으면,
웹서버는 페이지의 로직이나 데이터베이스(DB)의 연동을 위해 WAS에게 이들의 처리를 요청한다.
그러면 WAS는 이 요청을 받아 동적인 페이지처리를 담당하고,
DB에서 필요한 데이터 정보를 받아서 파일을 생성한다.

> 📍 **웹서버와 웹어플리케이션서버(WAS)의 차이점**
>
> - 웹서버 : 정적인 컨텐츠(HTML, CSS, IMAGE 등)를 요청받아 처리
> - WAS : 동적인 컨텐츠(JSP, ASP, PHP 등)를 요청받아 처리
>   => DB서버에 대한 접속 정보가 있기 때문에 외부에 노출 될 경우 보안상의 문제를 이유로 웹서버와의 연결을 통해 요청을 전달받음

### 7. 위의 작업처리 결과를 웹서버로 전송

### 8. 웹서버는 웹브라우저에게 html 문서결과를 응답

`response`는 `status code`로 서버 요청에 따른 상태를 보낸다.
총 5가지의 종류가 있는데,

- 1xx ▶️ 정보만 담긴 메세지
- 2xx ▶️ response 성공
- 3xx ▶️ 클라이언트를 다른 URL로 리다이렉트
- 4xx ▶️ 클라이언트 측에서 에러 발생
- 5xx ▶️ 서버 측에서 에러 발생

### 9. 웹브라우저는 화면에 웹페이지 내용물 출력

## **(3) 웹 브라우저에 네이버 를 검색하고 화면에 네이버 화면이 출력이 될 때 까지 내부적으로 어떤 동작들이 수행이 되는지 설명해주세요.**

1. 웹브라우저 인터페이스인 주소창에 사용자가 네이버를 검색
2. 웹브라우저가 HTTP를 사용하여 DNS 서버에 요청하여 도메인 주소를 요청
3. DNS서버가 웹브라우저에게 실제 주소 값인 IP주소를 받아오고 
   이 주소로 루트 요청
4. TCP로 연결이 되면 웹브라우저가 네이버서버에게 html 문서를 요청
5. 웹서버는 페이지 로직이나 DB 연동을 위해 WAS에게 처리 요청
6. WAS는 DB에 필요한 데이터 정보를 받아 파일을 생성하고 페이지 처리
7. 처리 결과를 웹서버로 전송
8. 웹서버는 웹브라우저에게 html문서 결과를 응답
9. 웹브라이주가 웹페이지 내용을 출력

------



tcp 연결형 서비스
가상회성 방식
전송 회선방식
전송 순서를 보장
수신 여부를 확인
1:1 통신
신뢰성높다
속도 느리다

TCP는 송신 호스트와 수신 호스트를 연결 하여 패킷전송을 위한 논리적 경로를 배정하는 가상 회선 방식을 제공
3-way handshaking 과정으로 발신지와 수신지를 설정을 확실하게 하여 정확한 전송 보장
이를 통해 높은 신뢰성을 보장하고 데이터의 흐름제어와 혼잡 제어가 가능
하지만 이러한 기능으로 UDP보다 속도가 느리다

udp 비연결형 서비스
데이터그램 방식
전송순서가 바뀔수있음
수신 여부를 확인 하지 않음
1:1 or 1:N or  N:N통신
신뢰성 낮다
속도 빠르다

## (2) `TCP` 와 `UDP` 의 차이를 작성해주세요.

TCP는 `연결 지향적 프로토콜`로 클라이언트가 서버로 연결 요청을 보내면 서버는 요청을 확인하고 선로를 고정시킨 뒤 데이터를 주고 받는 프로토콜입니다.
이러한 방식으로 데이터를 `안정적으로 정확`하게 보낼 수 있으며 또한 정상적으로 전송이 되었는지 확인하는 작업을 통해 호스트간 `신뢰성 있는 데이터 전달`과 `흐름제어`를 할 수 있습니다.
위와 같은 장점이 있지만 TCP는 데이터를 보내기 전 반드시 `1:1로 연결`되어야하고 UDP보다 데이터 전송 속도가 `느리다`는 단점이 있습니다.

UDP는 `비연결 지향적 프로토콜`로 연결 절차없이 일방적으로 데이터를 전송하는 프로토콜 입니다.
연결 과정이 없어 `빠른 전송`이 가능하지만 정보를 주고 받을 때 수신 여부를 확인하는 `신호절차가 없으며` 서로 다른 선로로 패킷이 전송되어 유실될 수 있기때문에 `신뢰성이 낮습니다`.

위의 내용을 정리하여 TCP와 UDP의 차이를 비교한 표입니다.

|                | TCP              | UDP                     |
| -------------- | ---------------- | ----------------------- |
| 연결방식       | 연결형           | 비 연결형 서비스        |
| 패킷 교환 방식 | 가상회선방식     | 데이터그램방식          |
| 전송 순서      | 전송 순서 보장   | 전송 순서가 바뀔수있음  |
| 수신 여부 확인 | 수신 여부를 확인 | 수신 여부확인 x         |
| 통신방식       | 1:1통신만 가능   | 1:1, 1:N, N:N 통신 가능 |
| 신뢰성         | 높음             | 낮음                    |
| 속도           | 느림             | 빠름                    |

## (1) 동시에 같은 `DB Table row` 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.

질문과 같은 상황을 방어하기 위해 락킹, 타임스탬프, 낙관적 검증, MVCC과 같은
동시성 제어 기법을 사용하여 개발할 것입니다.

락킹(Locking)은 트랜잭션이 사용하는 데이터에 잠금(Lock)을 설정하게 되면 해제(Unlock)할 때까지 다른 트랜잭션은 해당 데이터에 수정, 접근, 삭제가 불가능한 상호 배제 기능을 제공하는 기법입니다. 연산 종류로 공유 잠금(Shared Lcok)은 해당 트랜잭션 또는 다른 트랜잭션은 데이터 항목에 대해 읽기만 가능하여 전용 잠금(Exclusive Lock)은 해당 트랜잭션은 데이터 항목에 대해 읽기, 수정이 모두 가능하지만 다른 트랜잭션은 읽기, 쓰기 모두 할 수 없습니다.

타임스탬프(Timestamp)는 DBMS에서 지정하는 고유번호인 타임스탬프를 트랜잭션에 부여하여 트랜잭션간의 순서를 미리 정하는 기법입니다.
타임스탬프 종류로 시스템 클럭(System Clock)은 트랜잭션이 시스템에 들어왔을 때 시스템 시간을 적용하는 것이며 논리적 계수기(Logical Count)는 트랜잭션이 발생할 때마다 카운트를 하나씩 증가하는 것입니다.

낙관적 검증은 트랜잭션 수행 중에는 데이터 항목들이 지역 사본에 대해서만 갱신이 이루어지고 트랜잭션 종료후에는 동시성을 위한 트랜잭션 직렬화 검증 후 DB에 반영하는 기법입니다.
낙관적 검증 수행 단계로 먼저 판독단계(Read Phase)에서 트랜잭션 작업 구역에 지역 사본으로 만들어 읽기와 갱신을 수행하고 확인단계(Vaildation Phase)에서 DB에 반영하기 전 충돌 직렬 가능성을 검사합니다. 마지막으로 기록단계(Write Phase)에서는 확인단계를 통과한 트랜잭션의 실행결과를 실제 DB에 반영하고 그렇지 않으면 트랜잭션을 취소하고 다시 재시작합니다.

다중버전 병행제어 기법(MVCC : Multi Version Concurrency Control)은 동시 접근을 허용하는 DB에서 동시성을 제어하기 위해 사용되며 트랜잭션의 타임스탬프와 접근하려는 데이터의 여러 버전의 타임스탬프를 비교 후 직렬 가능성이 보장되는 적절한 버전을 선택해 접근하도록 하는 기법입니다.

| 동시성제어 기법 | 장점                                                         | 단점                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 락킹            | 알고리즘이 간단<br />데이터 오류 가능성 예방가능             | Deadlcok발생<br />Lock대기시간 발생                          |
| 타임스탬프      | Deadlock발생 없음<br />트랜잭션 대기시간 없음                | Rollback 발생확률이 높다<br />cascading Rollback 가능성 있음 |
| 낙관적 검증     | 동시 처리<br />트랜잭션 대기시간 없음                        | 장기 트랜잭션 철회시 자원이 낭비                             |
| MVCC            | 잠금을 사용하지 않아 <br />일반 RDBMS보다 빠르게 작동<br />일관성, 동시성 모두 해결 | Undo 블록 I/O에 따른 오버헤드 발생<br />사용하지 않는 데이터가 쌓여 정리 시스템 필요 |



## (4) 본인이 주력으로 사용하는 언어에서 설계적 결함 한 가지를 작성해주세요. .

자바의 설계적 결함 중 하나는 `불편한 예외처리`입니다.
자바의 철학은 "잘못 만든 코드는 실행되지 않아야 한다."로 높은 안정성을 위해 `상황에 맞는 예외처리가 무조건 사용`됩니다. 이러한 이유로 catch되지 않은 예외는 반드시 해당메서드에 throw 선언을 해줘야하며 하지 않을 경우 디버깅이 되지 않는 불편함이 있습니다.



## (5) 본인이 주력으로 사용하는 언어에서 자료구조와 관련 된 클래스가 내부적으로 어떻게 동작하는지 한 가지 사례를 정하여 작성해주세요. ex) `ArrayList`, `HashMap` 등등

## LinkedList

최근에 코테문제를 풀면서 사용했던 LinkedList에 대해 자세히 알아보기위해 선정하게되었습니다.

```java
List<String> list = new LinkedList<>();
```

링크드리스트를 선언하기 위해 위와 같은 코드를 작성하여 선언합니다.
이제 클래스 내부로 들어가보겠습니다.

```java
/**
* Constructs an empty list.
*/
public LinkedList() {
}
```

new 생성자를 사용하여 String 타입의 LinkedList를 생성한 모습인데 파라미터로 아무것도 넘겨주지 않았기 때문에 default 빈 생성자를 호출합니다.

```java
/**
* Pointer to first node.
*/
transient Node<E> first;

/**
* Pointer to last node.
*/
transient Node<E> last;


private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

LinkedList의 내부변수로 firstNode와 lastNode가 있으며 이것의 클래스인 Node를 보면 데이터를 저장하는 item, 다음 노드값 next, 이전 노드값 prev 그리고 Node 클래스 생성자를 확인할 수 있습니다.

add

```java
list.add("h");
```

위와같이 list에 add매서드를 사용하게 되면 내부에서 어떻게 동작하는지 확인해보겠습니다.

```java
/**
* Appends the specified element to the end of this list.
*
* <p>This method is equivalent to {@link #addLast}.
*
* @param e element to be appended to this list
* @return {@code true} (as specified by {@link Collection#add})
*/
public boolean add(E e) {
	linkLast(e);
return true;
}

public void addFirst(E e) {
    linkFirst(e);
}
/**
* Appends the specified element to the end of this list.
*
* <p>This method is equivalent to {@link #add}.
*
* @param e the element to add
*/
public void addLast(E e) {
    linkLast(e);
}
```

add를 하면 linkLast매서드를 통해 데이터를 추가하는 모습을 볼 수 있었고 addLast와 동일한 동작을 하는 메서드라고 적혀있습니다. 
addFirst는 linkFirst매서드를 통해 맨 처음에 데이터를 추가하는 것을 볼 수 있는데 이 메서드가 어떻게 동작하는지 보겠습니다.

```java
/**
* Links e as last element.
*/
void linkLast(E e) {
    final Node<E> l = last;
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}

/**
* Links e as first element.
*/
private void linkFirst(E e) {
    final Node<E> f = first;
    final Node<E> newNode = new Node<>(null, e, f);
    first = newNode;
    if (f == null)
        last = newNode;
    else
        f.prev = newNode;
    size++;
    modCount++;
}

```

linkLast메서드를 보면 새로운 노드를 생성하여 prev는 마지막 노드로 next는 null로 지정하고 마지막 노드의 next는 새로 생성한 노드로 설정합니다. 그 후 마지막노드가 변경되었으므로 last를 새로 생성한 노드를 가리키도록하는 것을 볼 수 있습니다. 
linkFirst메서드도 비슷하지만 새로운 노드의 prev는 null로 next는 첫번째 노드로 지정 후 first를 새로 생성한 노드를 가리키게합니다.

```java
/**
* Inserts the specified element at the specified position in this list.
* Shifts the element currently at that position (if any) and any
* subsequent elements to the right (adds one to their indices).
*
* @param index index at which the specified element is to be inserted
* @param element element to be inserted
* @throws IndexOutOfBoundsException {@inheritDoc}
*/
public void add(int index, E element) {
    checkPositionIndex(index);

    if (index == size)
    linkLast(element);
    else
    linkBefore(element, node(index));
}

private void checkPositionIndex(int index) {
    if (!isPositionIndex(index))
    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

private boolean isPositionIndex(int index) {
    return index >= 0 && index <= size;
}   

/**
* Returns the (non-null) Node at the specified element index.
*/
Node<E> node(int index) {
// assert isElementIndex(index);

    if (index < (size >> 1)) {
        Node<E> x = first;
    for (int i = 0; i < index; i++)
        x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
        x = x.prev;
        return x;
    }
}
/**
* Inserts element e before non-null Node succ.
*/
void linkBefore(E e, Node<E> succ) {
    // assert succ != null;
    final Node<E> pred = succ.prev;
    final Node<E> newNode = new Node<>(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
```

처음과 마지막이 아닌 중간에 값을 삽입하는 경우 add메서드를 사용하게됩니다.
먼저 CheckPositionIndex메서드를 사용하여 index의 값이 0~ size 사이의 값인지 판단하고 아니라면 IndexOutOfBoundsException예외를 발생시키는 것을 볼 수 있습니다.

다음 코드를 보면 index값의 범위가 size와 같다면 linkLast 메서드로 마지막에 삽입하고 아니라면 linkBefore 메서드로 삽입합니다.

node(int index)메서드를 사용하여 index가 size의 절반 이하라면 first를 기준으로, 아니라면 last를 기준으로 node를 찾습니다. 삽입할 데이터를 새로운 Node로 생성하고 찾은 node의 next로 지정합니다. 
